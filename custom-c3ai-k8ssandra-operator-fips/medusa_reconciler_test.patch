diff --git a/controllers/k8ssandra/medusa_reconciler_test.go b/controllers/k8ssandra/medusa_reconciler_test.go
index a2c7bad..0e8370b 100644
--- a/controllers/k8ssandra/medusa_reconciler_test.go
+++ b/controllers/k8ssandra/medusa_reconciler_test.go
@@ -3,6 +3,7 @@ package k8ssandra
 import (
 	"context"
 	"fmt"
+	"github.com/k8ssandra/k8ssandra-operator/pkg/meta"
 	"strings"
 	"testing"
 
@@ -33,6 +34,8 @@ const (
 	medusaConfigName       = "medusa-config"
 	prefixFromMedusaConfig = "prefix-from-medusa-config"
 	prefixFromClusterSpec  = "prefix-from-cluster-spec"
+
+	expectedServiceAccount = "c3cassandra"
 )
 
 func dcTemplate(dcName string, dataPlaneContext string) api.CassandraDatacenterTemplate {
@@ -136,6 +139,18 @@ func medusaTemplate(configObjectReference *corev1.ObjectReference) *medusaapi.Me
 	return &template
 }
 
+func testLabels() map[string]string {
+	return map[string]string{
+		"c3":   "ai",
+		"foo":  "bar",
+		"toto": "tutu",
+	}
+}
+
+func int64Ptr(i int64) *int64 {
+	return &i
+}
+
 func createMultiDcClusterWithMedusa(t *testing.T, ctx context.Context, f *framework.Framework, namespace string) {
 	require := require.New(t)
 
@@ -146,9 +161,91 @@ func createMultiDcClusterWithMedusa(t *testing.T, ctx context.Context, f *framew
 		},
 		Spec: api.K8ssandraClusterSpec{
 			Cassandra: &api.CassandraClusterTemplate{
+				DatacenterOptions: api.DatacenterOptions{
+					PodSecurityContext: &corev1.PodSecurityContext{
+						FSGroup:    int64Ptr(1001),
+						RunAsUser:  int64Ptr(1001),
+						RunAsGroup: int64Ptr(1001),
+					},
+				},
 				Datacenters: []api.CassandraDatacenterTemplate{
 					dcTemplate("dc1", f.DataPlaneContexts[0]),
 					dcTemplate("dc2", f.DataPlaneContexts[1]),
+					{
+						Meta: api.EmbeddedObjectMeta{
+							Name: "dc1",
+							Pods: meta.Tags{
+								Labels: testLabels(),
+							},
+						},
+						K8sContext: f.DataPlaneContexts[0],
+						Size:       3,
+						DatacenterOptions: api.DatacenterOptions{
+							ServiceAccount: expectedServiceAccount,
+							ServerVersion:  "3.11.14",
+							StorageConfig: &cassdcapi.StorageConfig{
+								CassandraDataVolumeClaimSpec: &corev1.PersistentVolumeClaimSpec{
+									StorageClassName: &defaultStorageClass,
+								},
+							},
+						},
+					},
+					{
+						Meta: api.EmbeddedObjectMeta{
+							Name: "dc2",
+							Pods: meta.Tags{
+								Labels: testLabels(),
+							},
+						},
+						K8sContext: f.DataPlaneContexts[1],
+						Size:       3,
+						DatacenterOptions: api.DatacenterOptions{
+							ServiceAccount: expectedServiceAccount,
+							ServerVersion:  "3.11.14",
+							StorageConfig: &cassdcapi.StorageConfig{
+								CassandraDataVolumeClaimSpec: &corev1.PersistentVolumeClaimSpec{
+									StorageClassName: &defaultStorageClass,
+								},
+							},
+						},
+					},
+				},
+			},
+			Medusa: &medusaapi.MedusaClusterTemplate{
+				ContainerImage: &images.Image{
+					Repository: medusaImageRepo,
+				},
+				StorageProperties: medusaapi.Storage{
+					StorageSecretRef: corev1.LocalObjectReference{
+						Name: cassandraUserSecret,
+					},
+				},
+				CassandraUserSecretRef: corev1.LocalObjectReference{
+					Name: cassandraUserSecret,
+				},
+				ReadinessProbe: &corev1.Probe{
+					InitialDelaySeconds: 1,
+					TimeoutSeconds:      2,
+					PeriodSeconds:       3,
+					SuccessThreshold:    1,
+					FailureThreshold:    5,
+				},
+				LivenessProbe: &corev1.Probe{
+					InitialDelaySeconds: 6,
+					TimeoutSeconds:      7,
+					PeriodSeconds:       8,
+					SuccessThreshold:    1,
+					FailureThreshold:    10,
+				},
+				Resources: &corev1.ResourceRequirements{
+					Limits: corev1.ResourceList{
+						corev1.ResourceCPU:    resource.MustParse("500m"),
+						corev1.ResourceMemory: resource.MustParse("1Gi"),
+					},
+					Requests: corev1.ResourceList{
+						corev1.ResourceCPU:    resource.MustParse("150m"),
+						corev1.ResourceMemory: resource.MustParse("500Mi"),
+					},
 				},
 			},
 			Medusa: medusaTemplateWithoutConfigRef(),
@@ -184,6 +281,8 @@ func createMultiDcClusterWithMedusa(t *testing.T, ctx context.Context, f *framew
 		return true
 	}, timeout, interval)
 
+	verifyStandaloneMedusaDeployment(t, medusaDeployment1)
+
 	require.True(f.ContainerHasEnvVar(medusaDeployment1.Spec.Template.Spec.Containers[0], "MEDUSA_RESOLVE_IP_ADDRESSES", "False"))
 
 	t.Log("check that the standalone Medusa service was created")
@@ -271,6 +370,8 @@ func createMultiDcClusterWithMedusa(t *testing.T, ctx context.Context, f *framew
 		return true
 	}, timeout, interval)
 
+	verifyStandaloneMedusaDeployment(t, medusaDeployment2)
+
 	t.Log("check that the standalone Medusa service was created in dc2")
 	medusaServiceKey2 := framework.ClusterKey{NamespacedName: types.NamespacedName{Namespace: namespace, Name: medusa.MedusaServiceName(k8ssandraClusterName, "dc2")}, K8sContext: f.DataPlaneContexts[1]}
 	medusaService2 := &corev1.Service{}
@@ -538,3 +639,39 @@ func creatingSingleDcClusterWithoutPrefixInClusterSpecFails(t *testing.T, ctx co
 	// verify the cluster still doesn't get created
 	require.Never(f.DatacenterExists(ctx, dc1Key), timeout, interval)
 }
+func verifyStandaloneMedusaDeployment(t *testing.T, deployment *appsv1.Deployment) {
+	t.Log("Verifying standalone Medusa deployment")
+
+	assert.Eventually(t, func() bool {
+		if deployment == nil {
+			t.Logf("Standalone Medusa deployment is nil")
+			return false
+		}
+
+		if actualSA := deployment.Spec.Template.Spec.ServiceAccountName; actualSA != expectedServiceAccount {
+			t.Logf("Standalone Medusa deployment service account is [%s], expected [%s]", actualSA, expectedServiceAccount)
+			return false
+		}
+
+		expectedLabels := testLabels()
+		// Ensure that label selector is unchanged
+		expectedLabels["app"] = deployment.Name
+
+		actualLabels := deployment.Spec.Template.Labels
+
+		assert.Equal(t, expectedLabels, actualLabels, "Standalone Medusa deployment labels are not as expected")
+		assert.NotNil(t, deployment.Spec.Template.Spec.SecurityContext, "Standalone Medusa deployment security context is nil")
+		if deployment.Spec.Template.Spec.SecurityContext == nil {
+			return false
+		}
+
+		var expectedUser int64 = 1001
+
+		// Ensure pod security context is set
+		assert.Equal(t, &expectedUser, deployment.Spec.Template.Spec.SecurityContext.RunAsUser, "Standalone Medusa deployment runAsUser is not set")
+		assert.Equal(t, &expectedUser, deployment.Spec.Template.Spec.SecurityContext.RunAsGroup, "Standalone Medusa deployment runAsGroup is not set")
+		assert.Equal(t, &expectedUser, deployment.Spec.Template.Spec.SecurityContext.FSGroup, "Standalone Medusa deployment fsGroup is not set")
+
+		return true
+	}, timeout, interval, "Standalone Medusa deployment is invalid")
+}
